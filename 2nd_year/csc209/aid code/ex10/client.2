Script started on Sat Mar 25 13:03:37 2017
]0;wangz154@b2220-11:/h/u15/c5/00/wangz154/CSC209/wangz154/ex10b2220-11:~/CSC209/wangz154/ex10$ gu db randclint  ent
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from randclient...done.
(gdb) break main
Breakpoint 1 at 0x4007fd: file randclient.c, line 16.
(gdb) run 127.0.0.1
Starting program: /h/u15/c5/00/wangz154/CSC209/wangz154/ex10/randclient 127.0.0.1

Breakpoint 1, main (argc=2, argv=0x7fffffffe638) at randclient.c:16
16	int main(int argc, char** argv) {
(gdb) n
18	  char message[18] = "A stitch in time\r\n";
(gdb) n
24	  if ((soc = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
(gdb) n
29	  peer.sin_family = AF_INET;
(gdb) n
30	  peer.sin_port = htons(PORT);
(gdb) n
31	  if (inet_pton(AF_INET, argv[1], &peer.sin_addr) < 1) {
(gdb) n
37	  if (connect(soc, (struct sockaddr *)&peer, sizeof(peer)) == -1) {
(gdb) n
42	  total_bytes = TIMES * sizeof(message);
(gdb) n
43	  current_byte = 0;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) nn
Undefined command: "nn".  Try "help".
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) 
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n
44	  while (current_byte < total_bytes) {
(gdb) n
45	    howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46	    bytes_left = total_bytes - current_byte;
(gdb) n
47	    if (howmany > bytes_left) {
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
51	      piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50	    for (int i = 0; i < howmany; i++) {
(gdb) n
53	    write(soc, piece, howmany);
(gdb) n
54	    current_byte += howmany;
(gdb) n quit
A debugging session is active.

	Inferior 1 [process 49166] will be killed.

Quit anyway? (y or n) y
]0;wangz154@b2220-11:/h/u15/c5/00/wangz154/CSC209/wangz154/ex10b2220-11:~/CSC209/wangz154/ex10$ exit
exit

Script done on Sat Mar 25 13:08:29 2017
